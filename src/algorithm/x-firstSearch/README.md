# 递归与回溯问题——解题模板总结
> 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。

## 搞清楚三个问题
  1. 什么时候用？（明确场景）
  2. 为什么这样用？（提供依据）
  3. 怎么用？（细化步骤）

## 什么时候用

### 看两个特征：
  1. 题目中暗示了一个或多个解，并且要求我们详尽地列举出每一个解的内容时，一定要想到 DFS、想到递归回溯。  
  2. 题目经分析后，可以转化为树形逻辑模型求解。

## 为什么这样用
递归与回溯的过程，本身就是穷举的过程。题目中要求我们列举每一个解的内容，解从哪来？解是基于穷举思想、对搜索树进行恰当地剪枝后得来的。   

## 怎么用
一个模型——树形逻辑模型；两个要点——递归式和递归边界。
树形逻辑模型的构建，关键在于找“坑位”，一个坑位就对应树中的一层，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容。至于递归边界，要么在题目中约束得非常清楚、要么默认为“坑位”数量的边界。  
用伪代码总结一下编码形式，大部分的题解都符合以下特征：  
```javascript
  function xxx(入参) {
  前期的变量定义、缓存等准备工作 
  
  // 定义路径栈
  const path = []
  
  // 进入 dfs
  dfs(起点) 
  
  // 定义 dfs
  dfs(递归参数) {
    if(到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关
      return   
    }
    
    // 注意这里也可能不是 for，视题意决定
    for(遍历坑位的可选值) {
      path.push(当前选中值)
      处理坑位本身的相关逻辑
      path.pop()
    }
  }
}
```

在面试中，如果你隐约觉得这道题用递归回溯来解可能有戏，却一时间没办法明确具体的解法，那么不妨尝试把这段伪代码记在脑子里。在面试时，先把框架写出来，然后结合题意去调整和填充伪代码的内容——很多时候，我们做题缺的不是知识储备，而是一个具体的切入点。